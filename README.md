# toolbox

I've made this toolbox to accomplish several things.

## 1. Convenience

This is to make a quick-reference, a type of link-based [commonplace book](https://en.wikipedia.org/wiki/Commonplace_book).

Since we don't write essays in machine code, _everyone_ exploits an abstraction when using computers. An OS is the equivalent of a vastly complicated multitool, but with modular pieces with use cases that range from a rocket ship to a chainsaw.

With the web, most people will download something, use it, then promptly forget about it. Then, months or years later, they'll rediscover it while researching a solution, then promptly forget it again. Repeat.

So, this makes my life convenient.

## 2. Awareness

I'm fairly certain many people remake existing software because they don't realize someone already made it.

Obviously, that's not *always* true:

- Refactoring is complicated, and it's often hard to find *precisely* what you want.
- Some software developers want to test to themselves/others whether they're smart.
- Sometimes it's very educational or downright *fun* to reinvent the wheel.
- If someone has severe trust issues, they'll make a de-(thing) version of that thing.

However, if I need something to stretch audio or batch-compare files, my largest mental hurdle is knowing it even *exists*. Even when a tool is obsolete, placed behind a paywall, merged into some other software suite, or just plain forgotten, that idea lives on and someone else will usually pick up the torch.

## 3. Future Convenience

I _might_ find lots of things here useful someday, but I don't feel like dragging around 4 terabytes of constantly updating programs just to know where they are.

So, this is a bit like a hoarder's barn, but collects less dust and is proportionally smaller. I will probably not use 95% of the stuff here, but someone else might, and I might run across them.

## Rules

For brevity's sake, I'm mostly glossing over a few groups:

- The built-in tools. If I need them, they're in the computer already.
- Paid tools, when they cost enough that it makes me pause to consider my budget.
- Most courses and courseware, since I'm convinced most of that is part of a *constantly* revolving cycle of technology fashions (Remember when Java and Netscape was going to run the world forever? By contrast, how about web browsers and corporation-endorsed programming languages?)

I've broken everything into malleable groupings, since there are *many* things that someone could use a computer for, and people are constantly adding new things. These groupings have a philosophical basis in their designed *final* purpose:

- Consuming: to experience others' created works without any creative goals in mind
- Foraging: to acquire others' creative works
- Calculators: to calculate a simple, usually numerical solution
- Communicating: to communicate with other people, directly or indirectly
- CySec: to protect from bad things happening to computers or information
- Hardware: to make or manage physical things, which includes computer hardware and OS-level things
- Visual: to visually design or adapt things which contain some intended aesthetic
- Audio: to work with sound for some intended aesthetic
- Text: to work with language for some intended aesthetic
- Dev: to broadly make or manage computer code, which is only referring to back-end because front-end is merely code-based visual design
- Productivity: to broadly streamline doing any of the above

## Earmarks

- _*_ if it's something to copy-paste or a reference sheet.
- ☁ for browser-based apps, ⇉ for a browser/software plugin or extension
- Desktop: ⊞ for Windows, ⌘ for Mac OS X, 🐧 for Linux and Friends.
- Mobile: 🤖 for Android, 🍎 for iOS.
- □ for non-UI CLI-based tools, often requires [programming experience](https://techsplained.xyz/prog-basics).
- ■ for standalone files or portable Windows apps (many through [PortableApps.com](https://portableapps.com/)).
- 🐍 if it runs in Python

These are volatile out-of-the-box OS estimations for several reasons:

- If the specs on a computer are high enough (and they often are if the software is >5 years old), you can make almost any software run on any popular OS. Quick-and-dirty still does the job, even if it's running on an MS-DOS emulator inside a Windows 98 VM.
- Developers keep making new things for new technologies, so this is constantly becoming obsolete (PR if you want to fix that).
- In ten years everyone might have BlahBlahOS where everything runs on it and these won't matter.

I also update a [pile of gists](https://gist.github.com/Phileosopher) for all the code-based and procedure-based things.

## What I'm looking for

Please PR if you see anything I've missed. Or, if tech's not your thing, contact me via "dave at stucky dot tech":

1. Things that are obsolete and their superior replacement.
2. Any relevant platforms/languages the tool needs (e.g., ⊞■⌘🐧🍎🤖⇉).
3. Any classes or sub-classes of tool I may have missed.

If you like what you see, feel free to fork, or visit [my website](https://stucky.tech) for other useful things.
