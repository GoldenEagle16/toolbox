# toolbox

I've made this toolbox to accomplish several things.

## 1. Convenience

This is to make a quick-reference, a type of link-based [commonplace book](https://en.wikipedia.org/wiki/Commonplace_book).

Since we don't write essays in machine code, _everyone_ exploits an abstraction when using computers. An OS is the equivalent of a vastly complicated multitool, but with modular pieces with use cases that range from a rocket ship to a chainsaw.

With the web, most people will download something, use it, then promptly forget about it. Then, months or years later, they'll rediscover it while researching a solution, then promptly forget it again. Repeat.

So, this makes my life convenient.

## 2. Awareness

I'm fairly certain many people remake existing software because they don't realize someone already made it.

Obviously, that's not _always_ true:

- Refactoring is complicated, and it's often hard to find _precisely_ what you want.
- Some software developers want to test to themselves/others whether they're smart.
- Sometimes it's very educational or downright _fun_ to reinvent the wheel.
- If someone has severe trust issues, they'll make an open-source or de-(thing) version of that thing.

However, if I need something to stretch audio or batch-compare files, the largest mental hurdle is knowing it even _exists_. I'm perfectly aware a tool can become obsolete, forced behind a paywall, merged into some other software suite, no longer supported, or [was closed-source the entire time](https://trendless.tech/floss). The idea, however, almost always lives on, and someone else typically reinvents it.

## 3. Future Convenience

I _might_ find lots of things here useful someday, but I don't feel like dragging around 4 terabytes of constantly updating programs just to know where they are.

So, this is a bit like a hoarder's barn, but collects less dust and is proportionally smaller. I will probably not use 95% of the stuff here, but someone else might, and I might run across them.

## Rules

The definition of "tool" is hairy. Every tool revolves around [human purpose](https://gainedin.site/purpose/), which is a concept created as a [relative human value](https://gainedin.site/values/), and [hackers](https://trendless.tech/hacking) can use _anything_ for a purpose it wasn't intended for.

For brevity's sake, I'm mostly glossing over a few groups:

- The built-in tools. If I need them, they're in the computer already.
- [Mega-corp](https://gainedin.site/groups-large) tools. They already have plenty of [advertising they paid for](https://notageni.us/marketing/), so they're _literally_ the first thing that comes up when you type the need into a search engine.
- Paid tools when they cost enough that it makes me pause to consider [my budget](https://adequate.life/money-3/). I'm a big proponent of [free licenses](https://trendless.tech/floss/) whenever possible.
- Most courses and courseware, since most of that is part of a _constantly_ revolving cycle of [technology fashions](https://trendless.tech/trends/) (Netscape and Java aren't running the planet anymore, but the concept of [web browsers](https://trendless.tech/web-dev/) and [programming languages endorsed by mega-corporations](https://trendless.tech/langs/) still are).
- Anything where [a scandal was attached to it](https://trendless.tech/faang), it's [highly politicized](https://gainedin.site/conservative-liberal), or it [got hacked](https://trendless.tech/hacking). I've got enough drama in my life without looking for it.

I've broken everything into malleable and somewhat arbitrary groupings, since there are _many_ things that someone could use a computer for, and people are constantly adding new things:

- Audio: to work with sound for some intended aesthetic
- Communicating: to communicate with other people, directly or indirectly
- Files/OS: to manage computer files or operating systems
- Games: to work and play with games
- Hardware: to make or manage physical things, which includes computer hardware
- Internet: a sub-division of computer networking that has its own subdomains
- Math: for calculation-specific needs
- Money: for lucre-specific needs
- Network: for computers across a network
- Text: to work with language for some intended aesthetic
- Visual: to visually design or adapt things which contain some intended aesthetic

Further, some patterns keep cropping up in each domain:

- Consuming: human consumption only, without modification to it
- Foraging: to acquire others' created works

Further further, there are other groups if it's too meta to fit into any one of the above categories:

- Dev: to broadly make or manage computer code, which may refer to front-end or back-end, be language-specific, and may simply be a more nuanced version of any of the above
- Productivity: to broadly streamline doing any of the above

## OS/Usage Earmarks

Sometimes, it makes sense to clarify for context how something is used.

- _*_ if it's something to copy-paste or a reference sheet.
- ☁ for browser-based apps, ⇉ for a browser/software plugin or extension
- Desktop: ⊞ for Windows, ⌘ for Mac OS X, 🐧 for Linux and Friends.
- Mobile: 🤖 for Android, 🍎 for iOS.
- □ for non-UI CLI-based tools, often requires [programming experience](https://trendless.tech/prog-basics).
- ■ for standalone files or portable Windows apps (many through [PortableApps.com](https://portableapps.com/)).
- 🔌 if it's an API or has API documentation
- ⦿ for a data-heavy tool that may interest devs
- 💾 if it's self-hostable
- 🐍 if it runs in Python
- 🕵️ if it helps with trust issues
- 🆓 if it's FLOSS

- $ if it does cost at least some money

These are volatile out-of-the-box OS estimations for several reasons:

- If the specs on a computer are high enough (and they often are if the software is >5 years old), you can make almost any software run on any popular OS. Quick-and-dirty still does the job, even if it's running on an MS-DOS emulator inside a Windows 98 VM on a ROM side-loaded on the SD card of a smartphone.
- Developers keep making new things for new technologies, so this is constantly becoming obsolete or adapting to new standards.
- In ten years a standard OS might have everything I've saved pre-installed on it, meaning this won't really matter.

## What I'm looking for

Please PR if you see anything I've missed. Or, if tech's not your thing, contact me via "dave at stucky dot tech":

1. Things that are obsolete and their superior replacement.
2. Any relevant platforms/languages the tool needs (e.g., ⊞■⌘🐧🍎🤖⇉).
3. Any classes or sub-classes of tool I may have missed.
4. Something that should be removed due to a scandal involved, politicization, or was hacked, preferably with a more open-source alternative.

If you like what you see, feel free to fork, or visit [my website](https://stucky.tech) for other useful things.
